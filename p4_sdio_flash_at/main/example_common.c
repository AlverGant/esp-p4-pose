/* ESP-AT Firmware Flasher for ESP32-C6 - UART Version */

#include <stdio.h>
#include <string.h>
#include <sys/param.h>
#include "example_common.h"
#include "esp_loader_io.h"

// ESP-AT flash addresses for ESP32-C6
#define BOOTLOADER_ADDRESS    0x0
#define PARTITION_ADDRESS     0x8000
#define OTA_DATA_ADDRESS      0xd000
#define AT_CUSTOMIZE_ADDRESS  0x1e000
#define MFG_NVS_ADDRESS       0x1f000
#define APP_ADDRESS           0x60000

// Symbols generated by bin2array from target_binaries/ESP32_C6
extern const uint8_t  ESP32_C6_bootloader_bin[];
extern const uint32_t ESP32_C6_bootloader_bin_size;
extern const uint8_t  ESP32_C6_bootloader_bin_md5[];

extern const uint8_t  ESP32_C6_partition_table_bin[];
extern const uint32_t ESP32_C6_partition_table_bin_size;
extern const uint8_t  ESP32_C6_partition_table_bin_md5[];

extern const uint8_t  ESP32_C6_ota_data_initial_bin[];
extern const uint32_t ESP32_C6_ota_data_initial_bin_size;
extern const uint8_t  ESP32_C6_ota_data_initial_bin_md5[];

extern const uint8_t  ESP32_C6_at_customize_bin[];
extern const uint32_t ESP32_C6_at_customize_bin_size;
extern const uint8_t  ESP32_C6_at_customize_bin_md5[];

extern const uint8_t  ESP32_C6_mfg_nvs_bin[];
extern const uint32_t ESP32_C6_mfg_nvs_bin_size;
extern const uint8_t  ESP32_C6_mfg_nvs_bin_md5[];

extern const uint8_t  ESP32_C6_esp_at_bin[];
extern const uint32_t ESP32_C6_esp_at_bin_size;
extern const uint8_t  ESP32_C6_esp_at_bin_md5[];

static const char *get_error_string(const esp_loader_error_t error)
{
    const char *mapping[ESP_LOADER_ERROR_INVALID_RESPONSE + 1] = {
        "NONE", "UNKNOWN", "TIMEOUT", "IMAGE SIZE",
        "INVALID MD5", "INVALID PARAMETER", "INVALID TARGET",
        "UNSUPPORTED CHIP", "UNSUPPORTED FUNCTION", "INVALID RESPONSE"
    };
    return mapping[error <= ESP_LOADER_ERROR_INVALID_RESPONSE ? error : 0];
}

void get_esp_at_binaries(esp_at_binaries_t *bins)
{
    // Bootloader at 0x0
    bins->bootloader.data = ESP32_C6_bootloader_bin;
    bins->bootloader.size = ESP32_C6_bootloader_bin_size;
    bins->bootloader.md5  = ESP32_C6_bootloader_bin_md5;
    bins->bootloader.addr = BOOTLOADER_ADDRESS;

    // Partition table at 0x8000
    bins->partition.data = ESP32_C6_partition_table_bin;
    bins->partition.size = ESP32_C6_partition_table_bin_size;
    bins->partition.md5  = ESP32_C6_partition_table_bin_md5;
    bins->partition.addr = PARTITION_ADDRESS;

    // OTA data at 0xd000
    bins->ota_data.data = ESP32_C6_ota_data_initial_bin;
    bins->ota_data.size = ESP32_C6_ota_data_initial_bin_size;
    bins->ota_data.md5  = ESP32_C6_ota_data_initial_bin_md5;
    bins->ota_data.addr = OTA_DATA_ADDRESS;

    // AT customize at 0x1e000
    bins->at_customize.data = ESP32_C6_at_customize_bin;
    bins->at_customize.size = ESP32_C6_at_customize_bin_size;
    bins->at_customize.md5  = ESP32_C6_at_customize_bin_md5;
    bins->at_customize.addr = AT_CUSTOMIZE_ADDRESS;

    // MFG NVS at 0x1f000
    bins->mfg_nvs.data = ESP32_C6_mfg_nvs_bin;
    bins->mfg_nvs.size = ESP32_C6_mfg_nvs_bin_size;
    bins->mfg_nvs.md5  = ESP32_C6_mfg_nvs_bin_md5;
    bins->mfg_nvs.addr = MFG_NVS_ADDRESS;

    // ESP-AT app at 0x60000
    bins->app.data = ESP32_C6_esp_at_bin;
    bins->app.size = ESP32_C6_esp_at_bin_size;
    bins->app.md5  = ESP32_C6_esp_at_bin_md5;
    bins->app.addr = APP_ADDRESS;
}

esp_loader_error_t connect_to_target(uint32_t higher_transmission_rate)
{
    esp_loader_connect_args_t connect_config = ESP_LOADER_CONNECT_DEFAULT();
    esp_loader_error_t err = esp_loader_connect(&connect_config);
    if (err != ESP_LOADER_SUCCESS) {
        printf("Cannot connect to target. Error: %s\n", get_error_string(err));
        return err;
    }
    printf("Connected to target\n");

    // Change to higher baud rate for faster flashing
    if (higher_transmission_rate) {
        err = esp_loader_change_transmission_rate(higher_transmission_rate);
        if (err != ESP_LOADER_SUCCESS) {
            printf("Unable to change transmission rate on target.\n");
            return err;
        }
        err = loader_port_change_transmission_rate(higher_transmission_rate);
        if (err != ESP_LOADER_SUCCESS) {
            printf("Unable to change transmission rate on host.\n");
            return err;
        }
        printf("Transmission rate changed to %lu baud.\n", (unsigned long)higher_transmission_rate);
    }

    return ESP_LOADER_SUCCESS;
}

// Simple flash_binary for UART - no chunking needed
esp_loader_error_t flash_binary(const uint8_t *bin, size_t size, size_t address)
{
    esp_loader_error_t err;
    static uint8_t payload[1024];
    const uint8_t *bin_addr = bin;

    printf("Erasing flash at 0x%x (%u bytes)...\n", (unsigned)address, (unsigned)size);
    err = esp_loader_flash_start(address, size, sizeof(payload));
    if (err != ESP_LOADER_SUCCESS) {
        printf("Erasing flash failed with error: %s.\n", get_error_string(err));
        return err;
    }

    size_t binary_size = size;
    size_t written = 0;

    while (size > 0) {
        size_t to_read = MIN(size, sizeof(payload));
        memcpy(payload, bin_addr, to_read);

        err = esp_loader_flash_write(payload, to_read);
        if (err != ESP_LOADER_SUCCESS) {
            printf("\nPacket could not be written! Error %s.\n", get_error_string(err));
            return err;
        }

        size -= to_read;
        bin_addr += to_read;
        written += to_read;

        int progress = (int)(((float)written / binary_size) * 100);
        printf("\rProgress: %d %%", progress);
        fflush(stdout);
    }

    printf("\nFinished programming\n");

#if MD5_ENABLED
    err = esp_loader_flash_verify();
    if (err != ESP_LOADER_SUCCESS) {
        printf("MD5 does not match. Error: %s\n", get_error_string(err));
        return err;
    }
    printf("Flash verified\n");
#endif

    return ESP_LOADER_SUCCESS;
}
